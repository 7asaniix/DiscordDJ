"use strict";var Discordie = require('discordie');var child_process = require('child_process');class InternalDJ {    constructor(bot, voiceConnection, wrapper, handler) {        this.bot = bot;        this.wrapper = wrapper;        this.handler = handler; // TODO: use it in the future        this.voiceConnection = voiceConnection;        this.playable = null;        this.musicQueue = [];        this.encoderCmd = null;        this.cmdCache = null;        this.process = null;        this.stream = null;        this.multithreaded = false;        this.stopping = false;        this.disconnectedEvent = function(info) {            if(info.voiceConnection == this.voiceConnection) this.destroy();        }.bind(this);        this.bot.Dispatcher.on(Discordie.Events.VOICE_DISCONNECTED, this.disconnectedEvent);    }    getCommand() {        if(this.cmdCache != null) return this.cmdCache;        var cmds = ["avconv", "ffmpeg", "avconv.exe", "ffmpeg.exe"];        if(this.encoderCmd != null) cmds.unshift(this.encoderCmd);        for(var i = 0; i < cmds.length; i++){            var p = child_process.spawnSync(cmds[i]);            if(!p.error) {                this.cmdCache = cmds[i];                return cmds[i];            }        }        return null;    }    destroy() {        this.bot.Dispatcher.removeListener(Discordie.Events.VOICE_DISCONNECTED, this.disconnectedEvent);    }    encodeStream(stream, sampleRate, channels) {        if(this.process != null) {            this.process.kill();        }        var command = this.getCommand();        if(command == null) {            console.log('FFmpeg was not found.');            this.destroy();            return null;        }        this.process = child_process.spawn(command, [            "-f", "s16le",            "-ar", sampleRate,            "-ac", channels,            "-af", "volume=1",            "pipe:1",            "-i", "-"        ]);        stream.pipe(this.process.stdin);        return this.process.stdout;    }    playStream(stream, sampleRate, channels, bitDepth) {        var options = {            frameDuration: 60,            sampleRate: sampleRate,            channels: channels,            float: false,            multiThreadedVoice: this.multithreaded        };        var readSize = sampleRate / 1000 * options.frameDuration * bitDepth / 8 * channels;        stream.once('readable', function() {            var encoder = this.voiceConnection.getEncoder(options);            var process = this.process;            var playable = this.playable;            encoder.onNeedBuffer = function() {                if(this.stopping) return;                if(process == null || process.killed) return;                if(this.playable != playable) return this.stop();                if(stream == null) return;                var chunk = stream.read(readSize);                if(!chunk) return setTimeout(encoder.onNeedBuffer, options.frameDuration);                var sampleCount = readSize / channels / (bitDepth / 8);                encoder.enqueue(chunk, sampleCount);            }.bind(this);            encoder.onNeedBuffer();        }.bind(this));    }    play(playable) {        this.stop();        this.playable = playable;        var sampleRate = 48000;        var bitDepth = 16;        var channels = 1;        playable.createStream(function(stream) {            this.stream = stream;            var encodedStream = this.encodeStream(this.stream, sampleRate, channels);            encodedStream.once('end', function() {                if(this.stopping) return;                this.skip();            }.bind(this));            encodedStream.once('readable', function() {                this.wrapper.emit('play');            }.bind(this));            this.playStream(encodedStream, sampleRate, channels, bitDepth);        }.bind(this));    }    stop() {        this.stopping = true;        if(this.process != null) {            if(!this.process.killed) {                if(this.stream != null) this.stream.unpipe(this.process.stdin);                this.process.kill();            }            this.process = null;        }        if(this.stream != null) {            try {                this.stream.end();            } catch(e) {}            this.stream = null;        }        this.stopping = false;    }    skip() {        this.stop();        if(this.playable != null) {            this.playable.removeAllListeners('data-changed');            this.playable = null;        }        this.wrapper.emit('skip');        if(this.playable == null && this.musicQueue.length > 0) {            this.play(this.musicQueue.shift());        }    }    addToQueue(playable) {        var self = this;        playable.on('data-changed', function() {            self.wrapper.emit('data-changed');        });        playable.loadData();        if(this.playable == null) {            this.play(playable);        } else {            this.musicQueue.push(playable);        }    }}module.exports = InternalDJ;