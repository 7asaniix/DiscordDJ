"use strict";var Discordie = require('discordie');var child_process = require('child_process');class InternalDJ {    constructor(bot, voiceConnection, wrapper, handler) {        this.bot = bot;        this.wrapper = wrapper;        this.handler = handler; /* TODO: use it in the future */        this.voiceConnection = voiceConnection;        this.playable = null;        this.musicQueue = [];        this.encoderCmd = null;        this.cmdCache = null;        this.process = null;        this.stream = null;        this.encoder = null;        this.multithreaded = false;        this.stopping = false;        this.disconnectedEvent = function(info) {            if(info.voiceConnection == this.voiceConnection) this.destroy();        }.bind(this);        this.bot.Dispatcher.on(Discordie.Events.VOICE_DISCONNECTED, this.disconnectedEvent);    }    getCommand() {        if(this.cmdCache != null) return this.cmdCache;        var cmds = ["avconv", "ffmpeg", "avconv.exe", "ffmpeg.exe"];        if(this.encoderCmd != null) {            cmds.unshift(this.encoderCmd);        } else {            cmds.unshift(process.cwd() + '/ffmpeg/ffmpeg');            cmds.unshift(process.cwd() + '/ffmpeg/ffmpeg.exe');        }        for(var i = 0; i < cmds.length; i++){            var p = child_process.spawnSync(cmds[i]);            if(!p.error) {                this.cmdCache = cmds[i];                return cmds[i];            }        }        return null;    }    destroy() {        this.bot.Dispatcher.removeListener(Discordie.Events.VOICE_DISCONNECTED, this.disconnectedEvent);    }    encodeStream(stream, sampleRate, channels) {        if(this.process != null) {            this.process.kill();        }        var command = this.getCommand();        if(command == null) {            console.log('The encoder was not found.');            this.destroy();            return null;        }        this.process = child_process.spawn(command, [            "-f", "s16le",            "-ar", sampleRate,            "-ac", channels,            "-af", "volume=1",            "pipe:1",            "-i", "-"        ]);        stream.pipe(this.process.stdin);        return this.process.stdout;    }    playStream(stream, sampleRate, channels, bitDepth) {        var options = {            frameDuration: 60,            sampleRate: sampleRate,            channels: channels,            float: false,            multiThreadedVoice: this.multithreaded        };        var readSize = sampleRate / 1000 * options.frameDuration * bitDepth / 8 * channels;        var process = this.process;        var playable = this.playable;        stream.once('readable', function() {            if(this.playable != playable) return;            this.encoder = this.voiceConnection.getEncoder(options);            if(this.encoder == null) return;            this.encoder.onNeedBuffer = function() {                if(this.stopping) return;                if(process == null || process.killed) return;                if(this.playable != playable) return this.stop();                if(stream == null) return;                var chunk = stream.read(readSize);                if(!chunk) return setTimeout(this.encoder.onNeedBuffer, options.frameDuration);                var sampleCount = readSize / channels / (bitDepth / 8);                this.encoder.enqueue(chunk, sampleCount);            }.bind(this);            this.encoder.onNeedBuffer();        }.bind(this));    }    play(playable) {        this.stop();        this.playable = playable;        var sampleRate = 48000;        var bitDepth = 16;        var channels = 2;        playable.createStream().then(function(stream) {            if(this.playable != playable) return;            this.stream = stream;            var encodedStream = this.encodeStream(this.stream, sampleRate, channels);            encodedStream.once('end', function() {                if(this.stopping) return;                if(this.playable != playable) return;                this.playable = null;                this.stream = null;                this.skip();            }.bind(this));            encodedStream.once('readable', function() {                if(this.playable != playable) return;                this.wrapper.emit('play');            }.bind(this));            this.playStream(encodedStream, sampleRate, channels, bitDepth);        }.bind(this), function(error) {            console.log("Music skipped by an error: " + error);            this.skip();        }.bind(this));    }    stop() {        if(this.stopping) return;        this.stopping = true;        try {            if(this.encoder != null) {                this.encoder.kill();            }            if(this.stream != null) {                if(this.process != null) this.stream.unpipe(this.process.stdin);                if(this.stream.end) this.stream.end();                if(this.stream.destroy) this.stream.destroy();                this.stream = null;            }            if(this.process != null) {                this.process.stdin.pause();                this.process.kill();                this.process = null;            }        } catch(e) {            console.log("An error ocurred while stopping the current music: " + e);        }        this.stopping = false;    }    skip() {        this.stop();        if(this.playable != null) {            this.playable.removeAllListeners('data-changed');            this.playable = null;        }        this.wrapper.emit('skip');        if(this.playable == null && this.musicQueue.length > 0) {            this.play(this.musicQueue.shift());        }    }    addToQueue(playable) {        var self = this;        playable.on('data-changed', function() {            self.wrapper.emit('data-changed');        });        playable.loadData();        if(this.playable == null) {            this.play(playable);        } else {            this.musicQueue.push(playable);        }    }}module.exports = InternalDJ;